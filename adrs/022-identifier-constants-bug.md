# ADR 022 - Identifier Contant Bug

### Status: Accepted

### Josh Holbrook

# Context

In ADR 019, we claimed that the bytecode for `for` loops was correct. However, this turned out not to be the case. This ADR documents what the bug was, and how it was fixed.

Recall that the following program:

```basic
10 rem A simple for loop
20 for i% = 1 to 10
30   print i%
40 endfor
```

Generated the following disassembled bytecode:

```
20  1   CONSTANT       i%
20  3   CONSTANT       1
20  5   DEFINE_GLOBAL  i%
20  7   CONSTANT       i%
20  9   GET_GLOBAL     i%
20  11  CONSTANT       10
20  13  LE
20  14  JUMP_IF_FALSE  14 -> 44
20  17  POP
20  18  JUMP           18 -> 36
20  21  CONSTANT       i%
20  23  CONSTANT       i%
20  25  GET_GLOBAL     i%
20  27  CONSTANT       1
20  29  ADD
20  30  SET_GLOBAL     i%
20  32  POP
20  33  LOOP           33 -> 7
30  36  CONSTANT       i%
30  38  GET_GLOBAL     i%
30  40  PRINT
40  41  LOOP           41 -> 21
40  44  NIL
40  45  RETURN
```

With the following constants table:

| constant index | value | relevant instructions                    |
| -------------- | ----- | ---------------------------------------- |
| 0              | `i%`  | `1 CONSTANT`, `5 DEFINE_GLOBAL`          |
| 1              | 1     | `3 CONSTANT`                             |
| 2              | `i%`  | `7 CONSTANT`, `9 GET_GLOBAL`             |
| 3              | 10    | `11 CONSTANT`                            |
| 4              | `i%`  | `21 CONSTANT`, `30 SET_GLOBAL`           |
| 5              | `i%`  | `23 CONSTANT`, `25 GET_GLOBAL`, `29 ADD` |
| 6              | 1     | `27 CONSTANT`, `29 ADD`                  |
| 7              | `i%`  | `36 CONSTANT`, `38 GET_GLOBAL`           |

In ADR 019, we claimed that the `CONSTANT i%` instructions were correct. This was under the mistaken belief that `DEFINE_GLOBAL`, `SET_GLOBAL` and `GET_GLOBAL` used those values on the stack. Instead, those instructions read the defined contant from the table directly, based on the following byte - the same as `CONSTANT`.

This may be seen in the implementation of the `OpCode.GetGlobal` instruction:

```typescript
case OpCode.GetGlobal:
  // Reads the constant, does not operate on the stack
  a = this.readString();
  b = this.globals[a];
  if (typeof b === 'undefined') {
    throw new NameError(`Variable ${a} is undefined`);
  }
  this.stack.push(b);
  break;
```

This means that these constant instructions are unnecessary.

This bug was caused by the implementations of `let` and `assign` emitting `OpCode.Constant` by calling a function called `emitIdent`:

```typescript
  private let_(variable: Variable, value: Expr | null): void {
    const target = this.emitIdent(variable.ident);
    if (value) {
      value.accept(this);
    } else {
      this.emitByte(OpCode.Nil);
    }
    this.emitBytes(OpCode.DefineGlobal, target);
  }
```

```typescript
  private emitIdent(ident: Token): Short {
    const constant = this.makeConstant(ident.value as Value);
    this.emitBytes(OpCode.Constant, constant);
    return constant;
  }
```

Note that we still need to _create_ the constant in the table! This is so that it may be read by a `*_GLOBAL` op code, as with the `CONSTANT` instruction.

A related bug uncovered by this fix is that we were attempting to pop the value stored by `SET_GLOBAL` twice - once with a `POP` instruction, and once within `SET_GLOBAL` itself.

This bug may be due to an undocumented attempt to optimize `SET_GLOBAL`. In `Crafting Interpreters`, Lox treats assignments as expressions, which evaluate to their assigned value. Matanuska BASIC, on the other hand, treats assignment as an instruction (or, in Lox parlance, a statement), and has no particular need to retain the value. The truth is lost to time.

It would be sensible for Matanuska BASIC to make this optimization, assuming there's no interest in allowing assignment as an expression (this has not been ruled out). However, this optimization will likely cause more bugs like this to be implemented in the future, as generated bytecode is based on an implementation which does not pop the value.

# Decision

First, the functions calling `emitIdent` will now call a function named `makeIdent` instead, which does not emit a `CONSTANT` instruction:

```typescript
  private makeIdent(ident: Token): Short {
    return this.makeConstant(ident.value as Value);
  }
```

Second, the `SET_GLOBAL` instruction will **not** pop its instruction automatically - at least, for now. In the future, if we commit to assignment being an instruction, and the bytecode implementation is complete, we may revisit this decision.

With these changes, the new disassembled output for the same `for` loop is:

```
20  1   CONSTANT       1
20  3   DEFINE_GLOBAL  i%
20  5   GET_GLOBAL     i%
20  7   CONSTANT       10
20  9   LE
20  10  JUMP_IF_FALSE  10 -> 34
20  13  POP
20  14  JUMP           14 -> 28
20  17  GET_GLOBAL     i%
20  19  CONSTANT       1
20  21  ADD
20  22  SET_GLOBAL     i%
20  24  POP
20  25  LOOP           25 -> 5
30  28  GET_GLOBAL     i%
30  30  PRINT
40  31  LOOP           31 -> 17
40  34  NIL
40  35  RETURN
```
