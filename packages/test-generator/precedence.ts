import { Config } from './config';
import { shuffle } from './util';

// Generate tests that exercise precedence behavior within the parser, by
// parsing "compilicated" expressions without clarifying groups.

type PrefixOp = { prefix: string };
type InfixOp = { infix: string };
type PostfixOp = { postfix: string };

type Op = PrefixOp | InfixOp | PostfixOp;

function isPrefix(op: any): op is PrefixOp {
  return op.prefix;
}

function isInfix(op: any): op is InfixOp {
  return op.infix;
}

/*
function isPostfix(op: any): op is PostfixOp {
  return op.postfix;
}
*/

const PREFIX_OPS = ['-'];
const INFIX_OPS = '+ - * / and or == >'.split(' ');
const POSTFIX_OPS = [];

const ops: Op[] = [
  ...PREFIX_OPS.map((o): Op => ({ prefix: o })),
  ...INFIX_OPS.map((o): Op => ({ infix: o })),
  ...POSTFIX_OPS.map((o): Op => ({ postfix: o })),
];

export function generatePrecedenceTest({ precedenceCount }: Config): string {
  let script = `// This test is automatically generated by @matanuska/test-generator.
// See ./packages/test-generator/README.md for more details.

import { describe, test, expect } from 'vitest';

import { FILENAME } from './helpers/files';
import { parseProgram } from './helpers/parser';

describe('operator precedence', () => {
`;

  for (let _ = 0; _ < precedenceCount; _++) {
    shuffle(ops);

    let expr = '1';
    let i = 2;
    for (const op of ops) {
      if (isPrefix(op)) {
        expr = op.prefix + expr;
      } else if (isInfix(op)) {
        expr = `${i} ${op.infix} ${expr}`;
        i++;
      } else {
        expr = `${expr} ${op.postfix} ${i}`;
        i++;
      }
    }

    // TODO: It's difficult to tell at a glance whether the output of a
    // generated test is correct. In the future, it may be preferable to
    // recreate the source and match against that instead of the AST directly.
    script += `  test('${expr}', () => {
    const [ast, warning] = parseProgram(\`10 ${expr}\`, FILENAME);

    expect('').toMatchSnapshot();
    // expect((ast.lines[0].instructions[0] as any).expression).toMatchSnapshot();
    expect('').toMatchSnapshot();
    // expect(warning).toMatchSnapshot();
  });

`;
  }

  script += '});';

  return script;
}
